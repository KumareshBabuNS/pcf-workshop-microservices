= CF Workshop Microservices Lab

== Intro

This lab demonstrates the benefits of deploying microservice applications to Cloud Foundry and building those applications with the Spring framework.

The lab starts with a monolithic v1 version of the cities-app, which is a Angular.js/Spring Boot/Spring Web/Spring Data application that provides a simple UI for searching for cities that are stored in a relational database. It's pushed as a single CF app.

It's a perfectly nice app, and does a lot with a little code thanks to the use of Spring Boot, Web and Data projects. But seeing the wisdom of microservices, you decide it's time to refactor this app into two tiers

* a microservice tier that  implements the core cities CRUD operations and provides a REST API via http://projects.spring.io/spring-data-rest/[Spring Data Rest]
* a UI tier that calls this REST API and uses a CF user provided service to reference the connection parameters from the CF environment

You'll deploy the refactoried v2 cities-app that implements an app for each tier, giving you the flexibility to update and scale each tier independently.

Then lab will then take you through a blue/green (or A/B) deployment to route 'production' traffic from your v1 app to your v2 app and demonstrate how the CF router simplifies application upgrades.

== Instructions

=== Login to PWS

Using the CF CLI, target and login to your run.pivotal.io account

[source,bash]
----
$ cf api api.run.pivotal.io
$ cf login
----

=== Deploy the v1 Monolithic Cities App

Clone or download the cities-monolithic app:

[source,bash]
----
$ git clone https://github.com/jholmes2001/cities-monolithic
----

Create the SQL database used to store the city data

[source,bash]
----
$ cf create-service cleardb spark cities-db
----

Validate that the service is created

[source,bash]
----
$ cf services
Getting services in org jholmes-org1 / space development as jahatpws@gmail.com...
OK

name             service       plan     bound apps
cities-db        cleardb       spark
----

Before pushing the app, take a look at the manifest.yml to see that 
		
* The host name (the URL prefix) is being set to cities-app-${random-word}. This will be the 'production URL' we reference in the blue/green deployment exercise.
* The app will bind to the cities-db you created earlier
* An environment variable 'VERSION' is being set to CITIES_APP_1_0

[source,bash]
----	
$ cd cities-monolithic
$ cat manifest.yml
---
applications:
- name: cities-monolithic
  memory: 512M
  instances: 1
  path: build/libs/cities-monolithic.jar
  timeout: 180
  services:
  - cities-db
  host: cities-app-${random-word}
  env:
    SPRING_PROFILES_ACTIVE: cloud
    JAVA_OPTS: -Djava.security.egd=file:///dev/urandom
    VERSION: CITIES_APP_1_0
----

Deploy the app

[source,bash]
----
$ cf push
----

Validate that the app is working by opening in a browser the url listed by 'cf apps'

[source,bash]
----	
$ cf apps
…
name                requested state   instances   memory   disk   urls   
cities-monolithic   started           1/1         512M     1G     cities-app-unplodding-tetrarch.cfapps.io 
----

Now that your v1 app is working, take a look at the https://github.com/jholmes2001/cities-monolithic/blob/master/src/main/java/com/example/cities/controller/CitiesController.java[CityController] to see that it is directly invoking a CityRepository object, based on Spring Data, and the UI and data tier are deployed as a single monolithic unit.

=== Deploy the V2 Microservices App

Now it's time to deploy the v2 microservice version of the app. Clone or download the v2 app:

[source,bash]
----
$ git clone https://github.com/jholmes2001/spring-boot-cities
$ cd spring-boot-cities
----

Under this folder are  3 subfolders

* cities-service - the microservice app
* cities-ui - the UI app that connects to the microservice
* cities-client - used by cities-ui to connect to microservice and includes use of Spring Cloud and Netflix Feign
		
** The **cities-client** subproject provides a client library for use by Java apps consuming the microservice. The main goal of this library is to show an example of a http://cloud.spring.io/spring-cloud-connectors[Spring Cloud Connectors] extension for consuming a microservice in a cloud environment.
**The client library uses https://github.com/Netflix/feign[Feign] to expose the microservice REST API using a http://martinfowler.com/eaaCatalog/repository.html[Repository] pattern. This provides a nice analog to the Repository abstraction used by Spring Data.
**The same Spring Cloud Connectors extension technique could be used to create lower-level REST API connection objects like Spring http://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#rest-resttemplate[RestTemplate] or https://hc.apache.org/httpcomponents-client-ga[Apache HttpClient].

First we'll deploy the cites-service microservice app

[source,bash]
----
$ cd cities-service
$ cf push
----

Use 'cf apps' to determine the URL to reference the cities microservice. We'll refer to this url as YOUR_CITIES_SERVICE_URL below, and in the example output below YOUR_CITIES_SERVICE_URL=cities-service-nonterminable-runback.cfapps.io
	
[source,bash]
----
$ cf apps
…
name                requested state   instances   memory   disk   urls   
cities-service      started           1/1         512M     1G     cities-service-nonterminable-runback.cfapps.io 
----

Validate that the REST endpoints are working for this service using curl

* Note: for Windows users, download cURL using following instructions below

** http://callejoabel.blogspot.com/2013/09/making-curl-work-on-windows-7.html

[source,bash]
----			
$ curl -i YOUR_CITIES_SERVICE_URL/cities
$ curl -i YOUR_CITIES_SERVICE_URL/cities/search
$ curl -i YOUR_CITIES_SERVICE_URL/cities/search/nameContains?q=TEMPLE
$ curl -i YOUR_CITIES_SERVICE_URL/cities/8291
----

* Create the cities-ws user provided service that will store the cities microservice connection parameters in the CF environment and make them available to the cities UI app.
** NOTE: YOU MUST USE 'http://' before your URL! (HTTPS will not work)

[source,bash]
----
$ cf create-user-provided-service cities-ws -p '{ "uri": "http://YOUR_CITIES_SERVICE_URL", "tag": "cities" }'
----

Validate the user provided service was created

[source,bash]
----
$ cf services
…
name             service         plan     bound apps   
cities-db        cleardb         spark    cities-monolithic, cities-service   
cities-ws        user-provided        
----

Now deploy the cities-ui front-end app that connects to the cities-service microservice

[source,bash]
----	
$ cd cities-ui
$ cf push
----

Test that the app works by opening the URL that is displayed by the 'cf apps' command. The UI should look the same as the V1 version, but it's of course getting the data from the cities microservice.

Take a look at the manifest.yml to see

* The app will bind to the cities-ws user provided service you just created
* The app will use cities-ui-${random-word} as the host (URL prefix)
* The app sets the VERSION environment variable to CITIES_APP_2_0

[source,bash]
----		
$ cat manifest.yml
---
applications:
- name: cities-ui
  memory: 512M
  instances: 1
  path: build/libs/cities-ui.jar
  services: [ cities-ws ]
  host: cities-ui-${random-word}
  env:
    SPRING_PROFILES_ACTIVE: cloud
    JAVA_OPTS: -Djava.security.egd=file:///dev/urandom
    VERSION: CITIES_APP_2_0
----

Now that the cities-ui app is pushed and bound to the cities-ws service, you can validate the URI value using 'cf env'

[source,bash]
----	
$ cf env cities-ui
…
System-Provided:
{
  "VCAP_SERVICES": {
    "user-provided": [
      {
        "credentials": {
          "tag": "cities",
          "uri": "http://cities-service-nonterminable-runback.cfapps.io"
        },
        "label": "user-provided",
        "name": "cities-ws",
        "syslog_drain_url": "",
        "tags": []
      }
    ]
  }
}

User-Provided:
JAVA_OPTS: -Djava.security.egd=file:///dev/urandom
SPRING_PROFILES_ACTIVE: cloud
VERSION: CITIES_APP_2_0
)
----

Now you can realize the benefits of having a separate microservice that can be scaled and deployed independently of the UI tier. 

=== Perform Blue/Green Deployment

Now you're ready to perform a blue/green deployment. First we'll list our existing routing table:

[source,bash]
----
$ cf routes
…
host                                      domain      apps
cities-service-nonterminable-runback      cfapps.io   cities-service
cities-app-unplodding-tetrarch            cfapps.io   cities-monolithic
cities-ui-slumberous-arroyo               cfapps.io   cities-ui
----

The host and domain listed for the cities-monolithic app is the 'production' URL that we want to remain constant during the upgrade process so the clients are not aware that the v1 app is being replaced by V2

We can validate that that this URL is referencing our V1 app by using the /cities/version request mapping to retrieve the VERSION environment variable

-- substitute your URL below
[source,bash]
----
$ curl cities-app-fanback-ineligibleness.cfapps.io/cities/version
CITIES_APP_1_0
----

We can also validate the version of the cities-ui route, which is our v2 app

[source,bash]
----
$ curl cities-ui-slumberous-arroyo.cfapps.io/cities/version
CITIES_APP_2_0
----

In a more realistic blue/green deployment scenario, we'd have a cluster of multiple V1 app instances deployed already, but since we're short on memory, we'll stick with our single instance.

Now we add our v2 'canary' to the v1 'cluster' my mapping the v1 route to cities-ui.

[source,bash]
----
$ cf map-route cities-ui cfapps.io -n cities-app-fanback-ineligibleness.cfapps.io
----

Now if we repeatedly visit our production URL, we'll see the CF router is load balancing requests between the v1 and v2 apps.

[source,bash]
----
$ curl cities-app-fanback-ineligibleness.cfapps.io/cities/version
CITIES_APP_1_0
$ curl cities-app-fanback-ineligibleness.cfapps.io/cities/version
CITIES_APP_2_0
----

As a final step in our blue/green deployment, after we've confirmed that our 'canary' v2 instance is behaving as expected, we retire the v1 app instances from the cluster my unmapping the production route to cities-monolithic.

[source,bash]
----
$ cf unmap-route cities-monolithic cfapps.io -n cities-app-fanback-ineligibleness.cfapps.io
----

Then test our production URL to see all traffic is going to V2:

[source,bash]
----
$ curl cities-app-fanback-ineligibleness.cfapps.io/cities/version
CITIES_APP_2_0
$ curl cities-app-fanback-ineligibleness.cfapps.io/cities/version
CITIES_APP_2_0
…
----

At this point we can delete our v1 app

[source,bash]
----
$ cf delete cities-monolithic
----
And have the choice of scaling either tier of our v2 app, i.e.

[source,bash]
----
$ cf scale cities-ui -i 2
$ cf scale cities-service -i 2
----

In the second case, cities-ui requests to cities-service will be automatically load balanced! 

Wow, microservices, Spring and CF are a great combination!

